import React, { useMemo, useState, useEffect, useRef } from "react";
import { jsPDF } from "jspdf";

// --- Helpers ---
const uid = () => Math.random().toString(36).slice(2, 10);
const STORAGE_KEY = "acro_jugements_v9"; // flow multi-pages + niveaux Fragile/Moyen/Bon

const DEFAULT_SECURITE_POINTS = [
  "R√¥les d√©finis (porteurs / voltige)",
  "Prises s√ªres et alignements",
  "Mont√©e contr√¥l√©e",
  "Tenue sans danger",
  "Descente s√©curis√©e",
];

// Types visibles avant usage
type TPyramideType = "p2" | "p3" | "p4" | "p5" | "libre";
const LABEL: Record<TPyramideType, string> = {
  p2: "Pyramide √† 2",
  p3: "Pyramide √† 3",
  p4: "Pyramide √† 4",
  p5: "Pyramide √† 5",
  libre: "Pyramide libre",
};
const NEED: Partial<Record<TPyramideType, number>> = { p2: 2, p3: 3, p4: 4, p5: 5 };

const COLORS: Record<TPyramideType, string> = {
  p2: "bg-sky-100 border-sky-200",
  p3: "bg-emerald-100 border-emerald-200",
  p4: "bg-amber-100 border-amber-200",
  p5: "bg-fuchsia-100 border-fuchsia-200",
  libre: "bg-gray-100 border-gray-200",
};

const DOT: Record<SecLevel, string> = { fragile: "üî¥", moyen: "üü°", bon: "üü¢" };

// T√©l√©chargements fiables (iOS/Safari compris)
function triggerDownload(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.setAttribute("download", filename);
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 0);
}

// Synchronise la liste d'√©l√®ves avec les pr√©noms du groupe
function syncEleves(
  prev: Array<{ name: string; note: number; avis: string }> = [],
  names: string[] = []
) {
  const by = new Map(prev.map((e) => [e.name, e] as const));
  return names.map((n) => by.get(n) || { name: n, note: 0, avis: "" });
}

// Champ multi-valeurs simple (chips)
function ChipInput({
  label,
  values,
  setValues,
  placeholder,
}: {
  label: string;
  values: string[];
  setValues: (vals: string[]) => void;
  placeholder?: string;
}) {
  const [input, setInput] = useState("");
  const ref = useRef<HTMLInputElement | null>(null);

  const add = (v: string) => {
    const t = (v || "").trim();
    if (!t) return;
    if ((values || []).includes(t)) return;
    setValues([...(values || []), t]);
    setInput("");
  };
  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter" || e.key === "," || e.key === ";") {
      e.preventDefault();
      add(input);
    } else if (e.key === "Backspace" && !input && (values || []).length) {
      setValues(values.slice(0, -1));
    }
  };
  const onPaste = (e: React.ClipboardEvent<HTMLInputElement>) => {
    const text =
      e.clipboardData && e.clipboardData.getData
        ? e.clipboardData.getData("text")
        : "";
    const TEST_RE = new RegExp("[,;\\n]");
    const SPLIT_RE = new RegExp("[ ,;\\n]+");
    const CRLF_RE = new RegExp("\\r\\n?", "g");
    if (text && TEST_RE.test(text)) {
      e.preventDefault();
      const normalized = text.replace(CRLF_RE, "\n");
      normalized
        .split(SPLIT_RE)
        .map((s) => s.trim())
        .filter(Boolean)
        .forEach(add);
    }
  };
  return (
    <div>
      <label className="text-sm text-gray-700">{label}</label>
      <div className="mt-1 flex flex-wrap gap-2 border rounded-xl p-2">
        {(values || []).map((v, i) => (
          <span
            key={i}
            className="px-2 py-1 rounded-full bg-gray-100 text-sm flex items-center gap-2"
          >
            {v}
            <button
              onClick={() => setValues(values.filter((_, idx) => idx !== i))}
              className="text-gray-500"
            >
              √ó
            </button>
          </span>
        ))}
        <input
          ref={ref}
          className="flex-1 min-w-[120px] outline-none"
          value={input}
          placeholder={placeholder}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={onKeyDown}
          onPaste={onPaste}
        />
        <button
          className="px-2 py-1 rounded-xl bg-blue-100 text-sm"
          onClick={() => add(input)}
        >
          Ajouter
        </button>
      </div>
    </div>
  );
}

// --- Types d'√©valuation ---
type SecLevel = "fragile" | "moyen" | "bon"; // au lieu de bool√©en

export default function App() {
  type Eleve = { name: string; note: number; avis: string };
  type Pyramide = {
    id: string;
    type: TPyramideType;
    securite: Record<string, SecLevel>; // FR/MOY/BON
    tenue: "non" | "oui";
  };
  type Eval = {
    id: string;
    date: string;
    observerList: string[];
    groupeList: string[];
    pyramides: Pyramide[]; // liste issue du plan
    composition: number;
    entree: number;
    sortie: number;
    originalite: number; // crit√®res d'ensemble
    noteFinale: number;
    commentaire: string;
    eleves: Eleve[];
  };

  const [evals, setEvals] = useState<Eval[]>([]);
  const [defaultObservers, setDefaultObservers] = useState<string[]>([]);
  const [defaultGroup, setDefaultGroup] = useState<string[]>([]);
  const [securitePoints] = useState<string[]>(DEFAULT_SECURITE_POINTS);
  const [bigUI, setBigUI] = useState(true);

  // Flow pages
  type Step = "cover" | "setup" | "observe" | "ensemble" | "individuel";
  const [step, setStep] = useState<Step>("cover");

  // Plan compteurs
  const [counts, setCounts] = useState<{
    p2: number;
    p3: number;
    p4: number;
    p5: number;
    libre: number;
  }>({ p2: 0, p3: 0, p4: 0, p5: 0, libre: 0 });
  const [selectedId, setSelectedId] = useState<string | null>(null);

  // Load
  useEffect(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        const p = JSON.parse(raw);
        setEvals(p.evals || []);
        setDefaultObservers(p.defaultObservers || []);
        setDefaultGroup(p.defaultGroup || []);
        setCounts(p.counts || { p2: 0, p3: 0, p4: 0, p5: 0, libre: 0 });
        setSelectedId(p.selectedId || null);
        setStep(p.step || "cover");
      }
    } catch {}
  }, []);
  useEffect(() => {
    localStorage.setItem(
      STORAGE_KEY,
      JSON.stringify({ evals, defaultObservers, defaultGroup, counts, selectedId, step })
    );
  }, [evals, defaultObservers, defaultGroup, counts, selectedId, step]);

  const makeSec = (): Record<string, SecLevel> =>
    Object.fromEntries(securitePoints.map((s) => [s, "fragile"])) as Record<string, SecLevel>;
  const makePyramide = (t: TPyramideType): Pyramide => ({ id: uid(), type: t, securite: makeSec(), tenue: "non" });

  // Ajouter UNE COMPOSITION et d√©marrer l'observation
  const addComposition = (goToObserve = false) => {
    const list: TPyramideType[] = [
      ...Array.from({ length: counts.p2 }, () => "p2" as TPyramideType),
      ...Array.from({ length: counts.p3 }, () => "p3" as TPyramideType),
      ...Array.from({ length: counts.p4 }, () => "p4" as TPyramideType),
      ...Array.from({ length: counts.p5 }, () => "p5" as TPyramideType),
      ...Array.from({ length: counts.libre }, () => "libre" as TPyramideType),
    ];
    const pyramides = list.map(makePyramide);
    const n: Eval = {
      id: uid(),
      date: new Date().toISOString(),
      observerList: defaultObservers, // transpos√©
      groupeList: defaultGroup, // transpos√©
      pyramides,
      composition: 0,
      entree: 0,
      sortie: 0,
      originalite: 0,
      noteFinale: 0,
      commentaire: "",
      eleves: syncEleves([], defaultGroup), // notes individuelles pr√™tes
    };
    setEvals((prev) => [n, ...prev]);
    setSelectedId(n.id);
    if (goToObserve) setStep("observe");
  };

  const updateEval = (id: string, patch: Partial<Eval>) =>
    setEvals((prev) => prev.map((e) => (e.id === id ? { ...e, ...patch } : e)));
  const selectedEval = useMemo(() => (evals || []).find((e) => e.id === selectedId) || null, [evals, selectedId]);

  // Sync groupe‚Üí√©l√®ves sur la fiche s√©lectionn√©e (pour notes indiv)
  const setGroupeForSelected = (vals: string[]) => {
    if (!selectedEval) return;
    updateEval(selectedEval.id, { groupeList: vals, eleves: syncEleves(selectedEval.eleves || [], vals) });
  };

  // --- EXPORTS ---
  const exportPDF = () => {
    const doc = new jsPDF({ unit: "pt", format: "a4" });
    let y = 40;
    const maxW = 535;
    const newLine = (dy = 16) => { y += dy; if (y > 780) { doc.addPage(); y = 40; } };
    doc.setFontSize(14);
    doc.text("AcroSport ‚Äî Observations", 40, y);
    newLine(24);
    doc.setFontSize(11);

    (evals || []).forEach((e, i) => {
      const observers = (e.observerList || []).join(", ") || "(observateurs)";
      const groupe = (e.groupeList || []).join(", ") || "(groupe)";
      doc.text(`${i + 1}. ${groupe} (Obs: ${observers})`, 40, y);
      newLine();

      // Pyramides
      if ((e.pyramides || []).length) {
        doc.text("Pyramides de l'encha√Ænement:", 40, y);
        newLine();
        (e.pyramides || []).forEach((p, idx) => {
          const sec = Object.entries(p.securite).map(([k, v]) => `${DOT[v]} ${k}`).join(" ‚Ä¢ ");
          doc
            .splitTextToSize(`${idx + 1}. ${LABEL[p.type]} ‚Äî Tenue: ${p.tenue.toUpperCase()} ‚Äî S√©curit√©: ${sec}`, maxW)
            .forEach((ln) => { doc.text(ln, 40, y); newLine(14); });
        });
        newLine(6);
      }

      // Crit√®res d'ensemble
      doc.text(
        `Ensemble ‚Äî Composition: ${e.composition}/5 | Entr√©e: ${e.entree}/5 | Sortie: ${e.sortie}/5 | Originalit√©: ${e.originalite}/5`,
        40,
        y
      );
      newLine();
      doc.text(`Note finale /20: ${e.noteFinale}`, 40, y);
      newLine(8);
      if (e.commentaire) {
        doc.splitTextToSize(`Commentaire: ${e.commentaire}`, maxW).forEach((ln) => { doc.text(ln, 40, y); newLine(14); });
      }
      newLine(8);

      // √âval individuelle
      if ((e.eleves || []).length) {
        doc.setFontSize(12);
        doc.text("√âvaluation individuelle", 40, y);
        newLine();
        doc.setFontSize(11);
        (e.eleves || []).forEach((el) => {
          doc.text(`‚Ä¢ ${el.name} ‚Äî Note: ${el.note || 0}/20`, 40, y);
          newLine();
          if (el.avis) {
            doc.splitTextToSize(`   Avis: ${el.avis}`, maxW).forEach((ln) => { doc.text(ln, 40, y); newLine(14); });
          }
        });
        newLine(10);
      }

      if (y > 760) { doc.addPage(); y = 40; }
    });

    // Footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(9);
      doc.setTextColor(120);
      doc.text(`AcroSport ‚Äî Export du ${new Date().toLocaleDateString()}  ‚Ä¢  Page ${i}/${pageCount}` , 40, 820);
      doc.setTextColor(0);
    }

    doc.save(`acro_eval_${new Date().toISOString().slice(0, 10)}.pdf`);
  };

  const exportCSV = () => {
    const headers = [
      "index","date","observateurs","groupe",
      "p2","p3","p4","p5","libre","total_pyramides",
      "composition","entree","sortie","originalite","noteFinale",
      ...securitePoints.map((s) => `SECURITE:${s} (F/M/B)`),
      "eleves:noms","eleves:notes","eleves:avis",
    ];

    const rows = (evals || []).map((e, idx) => {
      const countsRow = { p2:0,p3:0,p4:0,p5:0,libre:0 } as Record<TPyramideType, number>;
      const secAgg: Record<string, { fragile:number; moyen:number; bon:number }> = Object.fromEntries(
        securitePoints.map((s) => [s, { fragile:0, moyen:0, bon:0 }])
      );
      (e.pyramides || []).forEach((p) => {
        countsRow[p.type]++;
        securitePoints.forEach((s) => {
          const lvl = p.securite[s];
          if (lvl) (secAgg[s] as any)[lvl]++;
        });
      });
      const n = (e.eleves || []).map((el) => el.name).join("|");
      const notes = (e.eleves || []).map((el) => el.note ?? 0).join("|");
      const avis = (e.eleves || []).map((el) => (el.avis || "").replace(/[\r\n]+/g, " ")).join("|");
      return [
        idx + 1,
        e.date,
        (e.observerList || []).join("|"),
        (e.groupeList || []).join("|"),
        countsRow.p2, countsRow.p3, countsRow.p4, countsRow.p5, countsRow.libre,
        (e.pyramides || []).length,
        e.composition, e.entree, e.sortie, e.originalite, e.noteFinale,
        ...securitePoints.map((s) => `${secAgg[s].fragile}/${secAgg[s].moyen}/${secAgg[s].bon}`),
        n, notes, avis,
      ];
    });

    const csv = [headers.join(";"), ...rows.map((r) => r.join(";"))].join("\n");
    const blob = new Blob(["\ufeff" + csv], { type: "text/csv;charset=utf-8;" });
    triggerDownload(blob, `acro_eval_${new Date().toISOString().slice(0, 10)}.csv`);
  };

  const exportJSON = () => {
    const blob = new Blob([
      JSON.stringify({ evals, defaultObservers, defaultGroup, counts, step }, null, 2),
    ], { type: "application/json" });
    triggerDownload(blob, `acro_eval_${new Date().toISOString().slice(0, 10)}.json`);
  };

  // R√©sum√©
  const totalCompos = evals.length;

  // --- UI helpers ---
  const Nav = ({ prev, next }: { prev?: Step; next?: Step }) => (
    <div className="flex justify-between gap-3">
      <button
        className={`px-4 py-2 rounded-2xl ${prev ? 'bg-gray-200' : 'bg-gray-100 opacity-50 cursor-not-allowed'}`}
        disabled={!prev}
        onClick={() => prev && setStep(prev)}
      >‚¨ÖÔ∏è Pr√©c√©dent</button>
      <button
        className={`px-4 py-2 rounded-2xl ${next ? 'bg-green-600 text-white' : 'bg-gray-100 opacity-50 cursor-not-allowed'}`}
        disabled={!next}
        onClick={() => next && setStep(next)}
      >Suivant ‚û°Ô∏è</button>
    </div>
  );

  // Auto-tests rapides pour √©viter les r√©gressions de parsing
  useEffect(() => {
    try {
      const pasted = "L√©o, In√®s;Sara\nNoah";
      const parts = pasted.replace(/\r\n?/g, "\n").split(/[ ,;\n]+/).map(s=>s.trim()).filter(Boolean);
      console.assert(parts.length === 4, 'Split coll√© noms √©chou√©', parts);
    } catch (e) {
      console.warn('Self-test failed', e);
    }
  }, []);

  return (
    <div className={`min-h-screen ${bigUI ? "text-[18px]" : "text-base"} bg-gray-50`}>
      <header className="sticky top-0 bg-white border-b shadow-sm p-3 flex justify-between items-center z-10">
        <h1 className="font-bold text-lg">ü§∏‚Äç‚ôÄÔ∏è AcroSport ‚Äî Observateur / Juge</h1>
        <div className="flex gap-2">
          <button className="bg-green-600 text-white rounded-2xl px-3 py-2" onClick={exportPDF}>üìÑ PDF</button>
          <button className="bg-blue-600 text-white rounded-2xl px-3 py-2" onClick={exportCSV}>‚¨áÔ∏è CSV</button>
          <button className="bg-purple-600 text-white rounded-2xl px-3 py-2" onClick={exportJSON}>üíæ JSON</button>
          <button className="bg-yellow-400 rounded-2xl px-3 py-2" onClick={()=>setBigUI(!bigUI)}>{bigUI? 'üîç UI XL':'üîé Normal'}</button>
        </div>
      </header>

      <main className="max-w-5xl mx-auto p-4 space-y-6">
        {/* COVER */}
        {step === 'cover' && (
          <section className="bg-gradient-to-br from-sky-50 to-emerald-50 rounded-3xl border p-8 text-center space-y-6">
            <h2 className="text-2xl font-bold">Bienvenue üëã</h2>
            <p className="text-gray-700">Cette application vous guide pas √† pas pour observer, juger et exporter les √©valuations d'AcroSport.</p>
            <div className="flex justify-center">
              <button className="px-6 py-3 rounded-2xl bg-green-600 text-white" onClick={()=>setStep('setup')}>Commencer</button>
            </div>
          </section>
        )}

        {/* SETUP : Observateurs + Groupe + Plan */}
        {step === 'setup' && (
          <>
            <section className="grid md:grid-cols-2 gap-4">
              <div className="rounded-2xl border border-emerald-200 bg-emerald-50 p-3">
                <ChipInput label="üëÄ Observateur¬∑rice(s)" values={defaultObservers} setValues={setDefaultObservers} placeholder="ex. Ambre, L√©o‚Ä¶" />
              </div>
              <div className="rounded-2xl border border-sky-200 bg-sky-50 p-3">
                <ChipInput label="üë• Groupe observ√© (par d√©faut)" values={defaultGroup} setValues={setDefaultGroup} placeholder="ex. In√®s, L√©o‚Ä¶" />
                <p className="text-xs text-sky-700 mt-2">Ces pr√©noms seront utilis√©s pour l'√©valuation individuelle.</p>
              </div>
            </section>

            <section className="bg-white rounded-2xl shadow p-4 space-y-3">
              <div className="flex items-center justify-between gap-3 flex-wrap">
                <div className="font-semibold">üóìÔ∏è Plan d'encha√Ænement</div>
                <div className="text-sm text-gray-500">Compositions: {totalCompos}</div>
              </div>
              <div className="grid sm:grid-cols-5 gap-3">
                {([
                  ['p2','Pyramide √† 2'],
                  ['p3','Pyramide √† 3'],
                  ['p4','Pyramide √† 4'],
                  ['p5','Pyramide √† 5'],
                  ['libre','Pyramide libre'],
                ] as Array<[TPyramideType,string]>).map(([k,label]) => (
                  <div key={k} className={`rounded-xl p-3 border ${COLORS[k]}`}>
                    <label className="text-sm font-medium">{label} √ó</label>
                    <input type="number" min={0} className="border rounded-xl px-3 py-2 w-full mt-1" value={(counts as any)[k]}
                      onChange={e=> setCounts({ ...counts, [k]: Math.max(0, Number(e.target.value)||0) } as any)} />
                  </div>
                ))}
              </div>
              <div className="flex gap-2 flex-wrap">
                <button className="bg-sky-600 text-white rounded-xl px-3 py-2" onClick={()=>addComposition(false)}>‚ûï Ajouter la composition</button>
                <button className="bg-emerald-600 text-white rounded-xl px-3 py-2" onClick={()=>addComposition(true)}>‚ñ∂Ô∏è D√©marrer l'observation</button>
                <button className="bg-gray-200 rounded-xl px-3 py-2" onClick={()=> setCounts({p2:0,p3:0,p4:0,p5:0,libre:0})}>R√©initialiser</button>
              </div>
            </section>

            <Nav prev={'cover'} next={'observe'} />
          </>
        )}

        {/* OBSERVE : par pyramide, couleurs + tenue oui/non + s√©curit√© FR/MOY/BON */}
        {step === 'observe' && selectedEval && (
          <section className="bg-white rounded-2xl shadow p-4 space-y-5">
            <div className="flex items-center justify-between">
              <div className="font-semibold">Observation ‚Äî {selectedEval.groupeList.join(', ') || 'groupe'}</div>
              <div className="text-sm text-gray-500">{(selectedEval.pyramides||[]).length} pyramide(s)</div>
            </div>

            <div className="grid md:grid-cols-2 gap-3">
              {selectedEval.pyramides.map((p, idx) => (
                <div key={p.id} className={`rounded-2xl p-3 border ${COLORS[p.type]} space-y-3`}>
                  <div className="flex items-center justify-between">
                    <div className="font-medium">#{idx+1} ‚Äî {LABEL[p.type]}</div>
                    <div className="text-xs">{NEED[p.type]? `${NEED[p.type]} √©l√®ves` : 'libre'}</div>
                  </div>

                  {/* Tenue */}
                  <div>
                    <span className="text-sm font-semibold">‚è±Ô∏è Tenue 3s</span>
                    <div className="grid grid-cols-2 gap-2 mt-2">
                      {(['non','oui'] as const).map(t => (
                        <button key={t} className={`px-3 py-2 rounded-xl font-semibold ${p.tenue===t? 'bg-green-600 text-white':'bg-gray-200'}`}
                          onClick={()=>{
                            const updated = selectedEval.pyramides.map(x=> x.id===p.id? { ...x, tenue:t } : x);
                            updateEval(selectedEval.id, { pyramides: updated });
                          }}>{t.toUpperCase()}</button>
                      ))}
                    </div>
                  </div>

                  {/* S√©curit√© F/M/B */}
                  <div>
                    <div className="text-sm font-semibold mb-1">üîí S√©curit√©</div>
                    <div className="space-y-2">
                      {securitePoints.map((crit, i)=>{
                        const lvl = p.securite[crit] || 'fragile';
                        const setLvl = (val: SecLevel) => {
                          const updated = selectedEval.pyramides.map(x=> x.id===p.id? { ...x, securite: { ...x.securite, [crit]: val } } : x);
                          updateEval(selectedEval.id, { pyramides: updated });
                        };
                        return (
                          <div key={i} className="bg-white rounded-xl p-2">
                            <div className="text-sm mb-1">{crit}</div>
                            <div className="grid grid-cols-3 gap-2">
                              {([['fragile','üî¥ Fragile'], ['moyen','üü° Moyen'], ['bon','üü¢ Bon']] as Array<[SecLevel,string]>).map(([k,l])=> (
                                <button key={k} className={`px-2 py-2 rounded-xl ${lvl===k? 'ring-2 ring-offset-2 ring-black bg-gray-100':'bg-gray-200'}`} onClick={()=>setLvl(k)}>{l}</button>
                              ))}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
              ))}
            </div>

            <Nav prev={'setup'} next={'ensemble'} />
          </section>
        )}

        {/* ENSEMBLE : curseurs 0‚Äì5 */}
        {step === 'ensemble' && selectedEval && (
          <section className="bg-white rounded-2xl shadow p-4 space-y-5">
            <div className="font-semibold">üìù √âvaluation de l'ensemble (0‚Äì5)</div>
            <div className="grid sm:grid-cols-2 gap-3">
              {([
                ['composition','Composition'],
                ['entree','Entr√©e'],
                ['sortie','Sortie'],
                ['originalite','Originalit√©'],
              ] as Array<[keyof Pick<Eval,'composition'|'entree'|'sortie'|'originalite'>,string]>).map(([key,label]) => (
                <div key={key} className="bg-gray-50 rounded-xl p-3">
                  <div className="flex items-center justify-between mb-2">
                    <span className="text-sm">{label}</span>
                    <div className="flex gap-2">
                      <button className="bg-gray-100 rounded-xl px-2" onClick={()=> updateEval(selectedEval.id, { [key]: Math.max(0,(selectedEval as any)[key]-1) } as any)}>‚àí</button>
                      <button className="bg-gray-100 rounded-xl px-2" onClick={()=> updateEval(selectedEval.id, { [key]: Math.min(5,(selectedEval as any)[key]+1) } as any)}>+</button>
                    </div>
                  </div>
                  <input type="range" min={0} max={5} step={1} value={(selectedEval as any)[key]||0} onChange={ev=> updateEval(selectedEval.id, { [key]: Number(ev.target.value) } as any) } className="w-full"/>
                  <div className="text-sm">Score : {(selectedEval as any)[key]||0}/5</div>
                </div>
              ))}
            </div>

            <div className="grid md:grid-cols-2 gap-3">
              <div>
                <span className="font-semibold">üóíÔ∏è Commentaire global</span>
                <textarea className="mt-2 w-full border rounded-xl p-2 min-h-[80px]" value={selectedEval.commentaire||''} onChange={e=> updateEval(selectedEval.id, { commentaire: e.target.value }) }/>
              </div>
              <div>
                <span className="font-semibold">üèÅ Note finale /20</span>
                <input type="number" min={0} max={20} value={selectedEval.noteFinale} onChange={ev=> updateEval(selectedEval.id, { noteFinale: Number(ev.target.value) }) } className="border rounded-xl px-3 py-2 w-24 ml-2"/>
              </div>
            </div>

            <Nav prev={'observe'} next={'individuel'} />
          </section>
        )}

        {/* INDIVIDUEL : notes + avis */}
        {step === 'individuel' && selectedEval && (
          <section className="bg-white rounded-2xl shadow p-4 space-y-5">
            <div className="font-semibold">üë§ √âvaluation individuelle des √©l√®ves</div>
            {(!selectedEval.groupeList || selectedEval.groupeList.length===0) && (
              <p className="text-sm text-gray-500 mt-1">Ajoute d'abord les pr√©noms du groupe (onglet Configuration).</p>
            )}
            {(selectedEval.eleves||[]).map((el,idx)=> (
              <div key={el.name+idx} className="mt-2 grid md:grid-cols-3 gap-2 items-start bg-gray-50 rounded-xl p-3">
                <div className="font-medium">{el.name}</div>
                <div>
                  <label className="text-sm">Note /20</label>
                  <input type="number" min={0} max={20} value={el.note||0} onChange={ev=>{ const arr=[...(selectedEval.eleves||[])]; arr[idx] = { ...arr[idx], note: Number(ev.target.value) }; updateEval(selectedEval.id,{ eleves: arr }); }} className="border rounded-xl px-3 py-2 w-24 ml-2"/>
                </div>
                <div className="md:col-span-2">
                  <label className="text-sm">Avis</label>
                  <textarea className="mt-1 w-full border rounded-xl p-2 min-h-[60px]" value={el.avis||''} onChange={ev=>{ const arr=[...(selectedEval.eleves||[])]; arr[idx] = { ...arr[idx], avis: ev.target.value }; updateEval(selectedEval.id,{ eleves: arr }); }}/>
                </div>
              </div>
            ))}

            <Nav prev={'ensemble'} next={undefined} />
          </section>
        )}
      </main>
    </div>
  );
}
